/* AT&T assembler */

1, .globl
 定义一个全局符号, 代码的任何地方都可以访问.

2, .balign arg1, arg2
 以当前地址开始,找到第一次出现的以第一个参数为整数倍的地址,并将其作为结束地址.
 在这个结束地址前面存储一个字节长度的数据,存储内容正是第二个参数.
 如果当前地址正好是第一个参数的倍数,则没有数据被写入到内存.

3, .word <arg>, [arg], ...
 预留一个或多个字的空间, 用来存放数据arg.
 类似的还有:
  - .byte 字节8 bits
  - .long 32 bits
  - .ascii 字符串
  - .asciz 字符串加'\0'

4, .equ <lable>, value
 在程序中用$lable使用value的值. 静态的, 值不能修改.

5, .type <lable>, function/object
 lable标签作为"函数(function)"或者"数据(object)"的开始.
 function/object前面可能要求有@/#前缀.

6, .fill length [, size, value]
 在data段, 预留length个size(默认是1byte)大小的缓冲区, 并用value(默认是0)初始化.
 e.g. 在buffer标签处预留1024个byte, 并初始化为0
  buffer:
   .fill 1024, 1, 0
  

7, .comm / .lcomm <lable>, length
 在bss段, 从内存标签lable开始预留length个bytes的缓冲区(不初始化).
 - .comm 可以用作.globl, 可以被外部访问.
 - .lcomm 不可用作.globl, 只能本地访问.

8, .extern func
 在汇编代码里声明一个外部函数. 链接时必须和用到的文件一起编译.
 p.s. 在c代码中调用汇编代码里的.globl函数时:
  extern void func(void);


/* inline assembly */
1, 扩展内嵌汇编的格式(external inline assembly format):
 __asm__("assembly code" : output locations : input operands : changned registers);

2, 全局变量: 可以直接引用

3, 寄存器: 需要用两个"%", e.g. "movl $1024, %%eax;"

4, 占位符: %<number>
 e.g. %0, %1, %2, %3...
 - 如果在一个代码块中使用了多个占位符, 则必须按%0, %1, %2...的顺序进行设置对应引用的输入输出值.
  e.g. func()中string设置%0, len设置%1.
 - 需要设置"约束符" (详见约束符表)

5, 使用内存位置
 设置好输入输出值的约束符即可.

6, 指定输入和输出:
 多个输入输出值用","(逗号)隔开.
+-----------+----------------------------------------+
| 约束符    | 描述                                   |
+-----------+----------------------------------------+
| 输入约束符                                         |
+-----------+----------------------------------------+
| a         | 使用%eax, %ax, %al寄存器               |
| b         | 使用%ebx, %bx, %bl寄存器               |
| c         | 使用%ecx, %cx, %cl寄存器               |
| d         | 使用%edx, %dx, %dl寄存器               |
| S         | 使用%esi, %si寄存器                    |
| D         | 使用%edi, %di寄存器                    |
| r         | 使用任意通用寄存器                     |
| q         | 使用%eax, %ebx, %ecx, %edx寄存器之一   |
| A         | 对于64位值,使用%eax和%edx寄存器        |
| f         | 使用浮点寄存器                         |
| t         | 使用第一个(顶部的)浮点寄存器           |
| u         | 使用第二个浮点寄存器                   |
| m         | 使用变量的内存位置                     |
| o         | 使用偏移内存位置                       |
| V         | 只使用直接内存位置                     |
| i         | 使用立即整数值                         |
| n         | 使用值已知的立即整数值                 |
| g         | 使用任何可用的寄存器或者内存位置       |
+-----------+----------------------------------------+
| 输出约束                                           |
+-----------+----------------------------------------+
| +         | 可读可写                               |
| =         | 只写                                   |
| %         | 如果需要操作数可以和下一个操作数切换   |
| &         | 在内联函数完成前,可以删除或者重新使用  |
+-----------+----------------------------------------+
